---
layout: post
title:  "Preorder traversal - Preorder нэвтрэлт"
date:   2020-07-07
categories: Binary Tree
---

Preorder нэвтрэлт нь боловруулалтыг эхлээд үндэс мөчир дээр, дараа нь зүүн дэд модон дээр, тэгээд баруун дэд модон дээр хийдэг алгоритм юм.

```java
class TreeNode{
    int data;
    TreeNode left;
    TreeNode right;
}
```

## Рекурсив preorder нэвтрэлт 

Рекурс байдлаар preorder нэвтрэлт хялбархөн бөгөөд бичиглэлийн хувьд ойлгомжтой болдог.

|                | Хугацаа         | Санах ой         |
|----------------|-----------------|------------------|
| Сайн нөхцөлд   | Ω( N )      | O(logN)             |
| Дундаж нөхцөлд | Θ( N )      | O(logN)             |
| Муу нөхцөлд    | O(  N )      | O(n)             | 

```java
public void preorder(TreeNode root){
    //Модны навч хүртэл нэвтэрсэн эсэхийг шалгаж байна.
    if(root!=null){

        //Ямар нэгэн боловсруулалт хийнэ.
        System.out.println(root.data);

        //Зүүн талын дэд модыг нэвтрэнэ.
        inorder(root.left);

        //Баруун талын дэд модыг нэврэнэ.
        inorder(root.right);
    }
}
```

## Stack ашиглан preorder нэвтрэх
Preorder нэвтрэлтийг stack ашиглан хялбархан хийж болно. 
Алгоримтын ерөнхий санаа нь үндсэн нүдийг нэвтэрсэний дараа Stack-ийг FILO шинж чанарыг ашиглан stack-д
баруун дэд мод, зүүн дэд модыг хадгална. Дараагийн ээлжинд stack-аас авахад зүүн дэд мод авагдаж энэ нь зүүн дэд мод баруун дэд модоос өмнө боловруулагдах баталгаа болно.

|                | Хугацаа         | Санах ой         |
|----------------|-----------------|------------------|
| Сайн нөхцөлд   | Ω( N )      | O(logN)             |
| Дундаж нөхцөлд | Θ( N )      | O(logN)             |
| Муу нөхцөлд    | O(  N )      | O(n)             | 
```java
public void preorder(TreeNode root){
     
     //Боловсруулалт хийх мод үүссэн эсэхийг баталгаажуулна. 
     if(root==null){
         return;
     }

     Stack<TreeNode> stack=new Stack<>();
     stack.push(root);

     while(!stack.isEmpty()){
          
          //нэвтрэх нүд
          root=stack.pop();
          //боловсруулалт хийнэ.
          System.out.println(root.data);

          //баруун дэд мод нэвтрэх шаардлагатай бол.
          if(root.right!=null){
              stack.push(root.right);
          }

          //зүүн дэд мод нэвтрэх шаардлагатай бол.
          if(root.left!=null){
              stack.push(root.left);
          }
     }

}
```

## Morris-ийн inorder нэвтрэлтийн алгоритм

Энэхүү алгоримт нь нэмэлт санах ой хэргэлдэггүйгээрээ онцлог бөгөөд нэмэлт санах ойны оронд навчнуудын баруун дэд модны заалтыг ашиглан буцах замаа санадаг. Ингэхдээ зүүн дэд модны хамгийн баруун навчыг ашиглах бөгөөд түүний баруун дэд мод хоосон байвал түр зуур буцах зам буюу нэвтэрч буй нүдийг хадгалаад, дараагийн удаа буцааж засна.
Энэ алгоримт хэдийгээр нэмэлт санах ой шаардахгүй боловч өмнөх алгоримтуудаас ялгаатай нь модны нүдүүдээр хоёр удаа дамжин өнгөрдөг байгаа.

|                | Хугацаа         | Санах ой         |
|----------------|-----------------|------------------|
| Сайн нөхцөлд   | Ω( N )      | O(1)             |
| Дундаж нөхцөлд | Θ( N )      | O(1)             |
| Муу нөхцөлд    | O( N )      | O(1)             | 


```java

public void preorder(TreeNode root){

    while(root!=null){

        //Хэрэв зүүн хязгаарт хүрээгүй бол
        if(root.left!=null){
            //зүүн дэд модны хамгийн баруун навчыг олно.
            TreeNode temp=root.left;
            //Хамгийн баруун навчны баруун мөчир хоосон юмуу өмнө нь нэвтрэх нүдийг заасан байх ёстой.
            while(temp.right!=null&&temp.right!=root){
                temp=temp.right;
            }

            //Хэрэв өмнө нь нэвтрэх нүдийг заасан бол
            if(temp.right!=null){
                //бид зүүн дэд модыг нэвтэрч дууссан гэсэн үг.
                //модыг засна.
                temp.right=null;

                //баруун дэд мод уруу нэвтрэнэ.
                root=root.right;
            }else{
                //үгүй бол өмнө нь энд ирж байгаагүй, зүүн дэд модыг нэвтрээгүй гэсэн үг
                //Тиймээс одоо боловсруулалт хийнэ.
                System.out.println(root.data);
                
                //буцах замаа хадгална.
                temp.right=root;
                //Тэгвэл зүүн дэд модыг нэвтрэнэ.
                root=root.left;
            }
        }else{
            //зүүн хязгаарт хүрсэн бол боловсруулат хийгээд
            System.out.println(root.data);

            //баруун мод уруу явна. Энэ нь бас буцах нүд байх боломжтой.
            root=root.right;
        }
    }
}
```