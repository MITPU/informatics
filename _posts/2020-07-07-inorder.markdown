---
layout: post
title:  "Inorder traversal - Inorder нэвтрэлт"
date:   2020-07-07
author: Ууганболд
category: Graph
---

Хоёртын модон дээр боловсруулалт хийхийн тулд тухайн модны мөчир, навч бүрээр дамжин өнгөрөх хэрэгтэй болдог.
Inorder нэвтрэлт нь боловруулалтыг эхлээд зүүн талын мөчир дээр хийгээд, дараа нь эцэг буюу одоогийн нүдэн дээр хийгээд, тэгээд баруун талын мөчир дээр хийдэг алгоритм юм.

{% highlight java %}
class TreeNode {
    int data;
    TreeNode left;
    TreeNode right;
}
{% endhighlight %}

# Рекурсив inorder нэвтрэлт
Рекурс байдлаар inorder нэвтрэлт хялбархөн бөгөөд бичиглэлийн хувьд ойлгомжтой болдог.

<center class="table-title">Хугацаа болон санах ойн үнэлгээ</center>

{:.time-space-complexity}
|                | Хугацаа         | Санах ой         |
|----------------|-----------------|------------------|
| Сайн нөхцөлд   | Ω( N )      | O(logN)             |
| Дундаж нөхцөлд | Θ( N )      | O(logN)             |
| Муу нөхцөлд    | O(  N )      | O(n)             |

{% highlight java %}
public void inorder(TreeNode root){
    //Модны навч хүртэл нэвтэрсэн эсэхийг шалгаж байна.
    if (root == null) {
        return;
    }

    //Зүүн талын мөчрийг эхэлж нэвтрэнэ.
    inorder(root.left);

    //Ямар нэгэн боловсруулалт хийнэ.
    System.out.println(root.data);

    //Баруун талын мөчрийг нэврэнэ.
    inorder(root.right);
}
{% endhighlight %}

# Stack ашиглан inorder нэвтрэх
Inorder нэвтрэлтийг stack ашиглан хялбархан хийж болно.
Алгоримтын ерөнхий санаа нь зүүн талын мөчир дуустал зүүн тийшээ нэвтэрч явна. Ингэж явахдаа буцах замаа Stack-д хадгалж (Үлгэрт ойд төөрөхгүйн тулд үртэс асгаж явдаг шиг) явах бөгөөд хэрэв зүүн мөчрийн хязгаарт хүрвэл нэг алхам эцэг уруугаа буцаж түүнд дээр боловсруулалт хийгээд баруун дэд мод уруу явна.

<center class="table-title">Хугацаа болон санах ойн үнэлгээ</center>

{:.time-space-complexity}
|                | Хугацаа         | Санах ой         |
|----------------|-----------------|------------------|
| Сайн нөхцөлд   | Ω( N )      | O(logN)             |
| Дундаж нөхцөлд | Θ( N )      | O(logN)             |
| Муу нөхцөлд    | O(  N )      | O(n)             |

{% highlight java %}
public void inorder(TreeNode root) {
     Stack<TreeNode> stack=new Stack<>();

     while(root != null || !stack.isEmpty()) {
          // Зүүн талын хязгаарт хүрээгүй байвал
          while(root != null) {
              // Буцах замаа санаад
              stack.push(root);
              // Зүүн тийшээ явна.
              root = root.left;
          }

          // Хязгаарт хүрсэн тохиолдолд нэг алхам ухраад
          root = stack.pop();

          // Боловсруулалт хийнэ.
          System.out.println(root.data);

          // Баруун дэд модыг нэвтрэнэ.
          root = root.right;
     }

}
{% endhighlight %}

## Morris-ийн inorder нэвтрэлтийн алгоритм

Энэхүү алгоримт нь нэмэлт санах ой хэргэлдэггүйгээрээ онцлог бөгөөд нэмэлт санах ойны оронд навчнуудын баруун дэд модны заалтыг ашиглан буцах замаа санадаг. Ингэхдээ зүүн дэд модны хамгийн баруун навчыг ашиглах бөгөөд түүний барын дэд мод хоосон байвал түр зуур буцах зам буюу нэвтэрч буй нүдийг хадгалаад, дараагийн удаа буцааж засна.
Энэ алгоримт хэдийгээр нэмэлт санах ой шаардахгүй боловч өмнөх алгоримтуудаас ялгаатай нь модны нүдүүдээр хоёр удаа дамжин өнгөрдөг байгаа.

<center class="table-title">Хугацаа болон санах ойн үнэлгээ</center>

{:.time-space-complexity}
|                | Хугацаа         | Санах ой         |
|----------------|-----------------|------------------|
| Сайн нөхцөлд   | Ω( N )      | O(1)             |
| Дундаж нөхцөлд | Θ( N )      | O(1)             |
| Муу нөхцөлд    | O( N )      | O(1)             | 


{% highlight java %}
public void inorder(TreeNode root) {
    while (root != null){
        // Хэрэв зүүн хязгаарт хүрээгүй бол
        if (root.left != null){
            // Зүүн дэд модны хамгийн баруун навчыг олно.
            TreeNode temp=root.left;

            // Хамгийн баруун навч хоосон юмуу өмнө нь нэвтрэх нүдийг заасан байх ёстой.
            while (temp.right != null && temp.right != root){
                temp = temp.right;
            }

            // Хэрэв өмнө нь нэвтрэх нүдийг заасан бол
            if (temp.right != null) {
                // бид зүүн дэд модыг нэвтэрч дууссан гэсэн үг.
                // Тиймээс одоо боловсруулалт хийнэ.
                System.out.println(root.data);

                // Модыг засна.
                temp.right = null;

                // Баруун дэд мод уруу нэвтрэнэ.
                root = root.right;
            } else {
                // Үгүй бол өмнө нь энд ирж байгаагүй, зүүн дэд модыг нэвтрээгүй гэсэн үг
                temp.right = root;

                // Тэгвэл зүүн дэд модыг нэвтрэнэ.
                root = root.left;
            }
        } else {
            // Зүүн хязгаарт хүрсэн бол боловсруулат хийгээд
            System.out.println(root.data);

            // Баруун мод уруу явна. Энэ нь бас буцах нүд байх боломжтой.
            root = root.right;
        }
    }
}
{% endhighlight %}
