---
layout: post
title:  "Рекурсив"
date:   2020-07-07 00:00:00 -0500
author: "Гантүшиг"
category: "рекурсив"
---
Рекурсив нь код бичих техник бөгөөд энгийн давталт ашиглан кодчилоход хэцүү бодлогыг гоёмсог шийдлээр боддог аргачлал юм. Рекурсивийг ашиглахдаа функц бичээд тэр функц дотор нь өөрийг нь дахин дуудаг. Тиймээс рекурсив функц бичихдээ зогсох нөхцөлийг сайн зааж өгөх хэрэгтэй. Учир нь зогсох нөхцөлгүй функц өөрийгөө дуудсаар дуусашгүй цикл үүснэ гэсэн үг.

Олон математик функцыг рекурсив ашиглан програмчилж болно. Энгийн нэг жишээ авч үзье. Өгөгдсөн $$ n $$ тооны факториалыг $$ (n!) $$ хэрхэн олох вэ? Үүнийг дараах байдлаар дүрсэлж болно.

$$
\begin{equation*}
    n! = \begin{cases}
               n*(n-1)!               & n \geq 1\\
               1                      & Бусад\\
           \end{cases}
\end{equation*}
$$

Одоо $$n!$$ олох $$f(n)$$ гэдэг функц бичье. Хэрэв энэ функцийг $$n=0$$ үед дуудвал, $$1$$ гэж буцаана. Энэ нь манай функцийн зогсох нөхцөл. Харин $$n≥1$$ үед $$f(n-1)$$ олсны дараа $$n!$$ олдоно.

```c++
int f(int n) {
  if (n >= 1) {
    return f(n - 1) * n;
  }
  return 1;
}
```

<img width="562" alt="image4" src="https://user-images.githubusercontent.com/12068641/86842716-7756fa80-c05a-11ea-8099-9461d6e4238c.png">


Факториал олохыг рекурсив ашиглан бодож болох ч дээрх зурагнаас харвал тийм ч оновчтой шийдэл биш. Үүнийг энгийн давталт бичээд амархан бодож болно. Харин рекурсив бүтэцтэй бодлогыг рекурсив ашиглан бодох нь илүү үр дүнтэй. Жишээ нь өгөгдсөн фолдерын нийт хэмжээг олох. Компютерт файлууд ихэвчлэн дараах бүтэцтэй хадгалагддаг.

<img width="516" alt="image2" src="https://user-images.githubusercontent.com/12068641/86842783-8dfd5180-c05a-11ea-9812-f75a8da62858.png">

_Өгөгдсөн фолдерын хэмжээ:_

{: style="margin-left: 10px" }
$$size(d) = size(f_{1}) +  size(f_{2}) + ... +  size(f_{m}) +  size(d_{1}) +  size(d_{2}) + ... +  size(d_{n})$$



# Java дээрх код

```java
// Хэрэглээ
System.out.println(getSize(new File(directory)) + “ bytes“);

long getSize(File file) {
  long size = 0;	// Бүх файлуулын нийт хэмжээг хадгална
  if (file.isDirectory()) {	// Тухайн файл фолдер эсэхийг шалгана
    File[] files = file.getFiles();	// Доторх бүх файл болон дэд фолдерууд
    for (int i = 0; files != null && i < files.length; i++)
      size = size + getSize(files[i]); 	// Рекурсив дуудалт
  } else {
    size = size + file.length();
  }

  return size;
}
```


Өөр нэг рекурсив ашиглавал хялбар Ханойн Цамхаг (Tower of Hanoi) бодлогон дээр илүү ойлгомжтой харагдана.

- $$1, 2, 3, … n$$ хэмжээтэй ялгаатай n ширхэг дискүүд болон $$A, B, C$$ гэсэн $$3$$ цамхаг бий.
- Дискийг өөрөөс нь жижиг хэмжээтэй дискэн дээр тавихгүй.
- Нэг удаагийн үйлдлээр нэг дискийг нэг цамхгаас нөгөөрүү шилжүүлж болно.
- Бүх дискүүд анх $$A$$ цамхагт байна.
- Зорилго нь бүх дискийг $$A$$ цамхагаас $$B$$ цамхагруу $$C$$ цамхагыг ашиглан шилжүүлэх.

<img width="521" alt="image3" src="https://user-images.githubusercontent.com/12068641/86843328-40cdaf80-c05b-11ea-9f82-bc222de65dfa.png">

$$n=3$$ үед шийдэл олоход хялбар харагдаж байна. Харин $$n$$ ихсэх тусам илүү ярвигтай болж эхэлнэ. Одоо рекурсив функцээ хэрхэн бичих талаар ярья. Функцийн маань зогсо$$х$$ нөхцөл нь $$n=1$$ үед шууд $$A$$ аас $$B$$ рүү шилжүүлнэ. Харин $$n>1$$ үед дараах дараалалаар хэрэгжүүлнэ.

- $$A$$ цамхагаас рекурсив ашиглан $$n - 1$$ дискүүдийг $$B$$-г ашиглан $$С$$ рүү шилжүүлнэ.
- $$A$$ цамхагаас хамгийн том хэмжээтэй диск $$n$$-ийг $$B$$ рүү шилжүүлнэ.
- Рекурсив ашиглан өмнөх $$С$$ цамхагт байгаа $$n-1$$ дискүүдийг $$A$$-г ашиглаж $$B$$ рүү шилжүүлнэ.

<img width="532" alt="image6" src="https://user-images.githubusercontent.com/12068641/86843380-50e58f00-c05b-11ea-819d-22460718f87d.png">

```java
moveDisks(n, 'A', 'B', 'C');

void moveDisks(int n, char fromTower, char toTower, char auxTower) {
  if (n == 1) {
    System.out.println("Move disk " + n + " from " + fromTower + " to " + toTower);
  } else {
    moveDisks(n - 1, fromTower, auxTower, toTower);
    System.out.println("Move disk " + n + " from " + fromTower + " to " + toTower);
    moveDisks(n - 1, auxTower, toTower, fromTower);
  }
}
```

$$n = 3$$ үед код хэрхэн ажилахыг харуулвал:

<img width="744" alt="image1" src="https://user-images.githubusercontent.com/12068641/86842838-9bb2d700-c05a-11ea-8b56-79b620811ec5.png">

# Дүгнэлт

Рекурсив нь кодыг хялбарчилдаг боловч бас сул тал бий. Функц нь шинээр өөрийгөө дуудах бүртээ local хувьсагчуудаа шинээр санах ойд авч байдаг учраас энгийн давталт ашиглах бодлогуудаас илүү санах ой ашиглана. Мөн тэдгээр санах ойг manage хийхийн тулд илүү хугацаа зарцуулна. Рекурсивээр бодож болох ихэнх бодлогуудыг давталт ашиглан бодож болно. Гэхдээ “directory-size” эсвэл “Tower of Hanoi” зэрэг бодлогуудыг рекурсив ашиглахгүй бодно гэвэл хүндрэлтэй учир ямар бодлогон дээр рекурсив ашиглах вэ гэдгээ сайн бодох хэрэгтэй.
